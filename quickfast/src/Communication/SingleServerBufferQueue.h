// Copyright (c) 2009, 2010, 2011, Object Computing, Inc.
// All rights reserved.
// See the file license.txt for licensing information.
//
#ifdef _MSC_VER
# pragma once
#endif
#ifndef SINGLESERVERBUFFERQUEUE_H
#define SINGLESERVERBUFFERQUEUE_H
// All inline, do not export.
//#include <Common/QuickFAST_Export.h>
#include "SingleServerBufferQueue_fwd.h"
#include <Communication/BufferQueue.h>

namespace QuickFAST
{
  namespace Communication
  {
    ///@brief Keep a queue of buffers waiting to be serviced by one server thread.
    ///
    /// Buffers may be generated by multiple threads, but must be serviced by a single
    /// thread (at any one time.)
    ///
    /// A thread with a buffer that needs to be processed locks a mutex and calls push()
    /// If push returns true that thread is now responsible for servicing the queue.
    /// To service the queue,
    ///    release the mutex (only one thread services at a time
    ///                        so no synchronization is needed)
    ///    for(bool more = startService();
    ///        more;
    ///        {lock} more = endservice(){unlock})
    ///    {
    ///       for buffer returned by serviceNext()
    ///         process buffer
    ///    }
    ///
    /// Synchronization is by an external mutex, to allow other data items to be synchronized by the
    /// same mutex.  Placeholder lock arguments help enforce the synchronization rules.  These
    /// locks are not actually used here.
    ///
    /// Note that the queue can be serviced without synchronization since only one thread will be
    /// doing the work.
    ///
    /// This object does not manage buffer lifetimes.  It assumes
    /// that buffers outlive the collection.
    class SingleServerBufferQueue
    {
    public:
      /// @brief Construct an empty queue.
      SingleServerBufferQueue()
        : busy_(false)
      {
      }

      /// @brief Push a buffer onto the queue.
      ///
      /// The unused scoped lock parameter indicates this method should be protected.
      /// @param buffer is the buffer to be added to the queue
      /// @returns true if if the queue needs to be serviced
      bool push(LinkedBuffer * buffer, boost::mutex::scoped_lock &)
      {
        //std::ostringstream msg;
        //msg << "Q:{"<< (void *) this <<  "} push @" <<(void *)buffer << std::endl;
        //std::cout << msg.str() << std::flush;

        incoming_.push(buffer);
        condition_.notify_one();
        return !busy_;
      }

      /// @brief Prepare to service this queue
      ///
      /// All buffers collected so far will be set aside to be serviced
      /// by this thread.  Any buffers arriving after this call will be
      /// held for later.
      ///
      /// If this method returns true, the calling thread MUST completely
      /// service the queue.
      ///
      /// The unused scoped lock parameter indicates this method should be protected.
      ///
      /// @returns true if if the queue is now ready to be serviced
      bool startService(boost::mutex::scoped_lock &)
      {
        if(busy_)
        {
          return false;
        }
        outgoing_.push(incoming_);
        busy_ = !outgoing_.isEmpty();
        //if(busy_)
        //{
        //  std::ostringstream msg;
        //  msg << "Q:{"<< (void *) this <<  "} startService " << std::endl;
        //  std::cout << msg.str() << std::flush;
        //}
        //else
        //{
        //  std::ostringstream msg;
        //  msg << "Q:{"<< (void *) this <<  "} idle at startService" << std::endl;
        //  std::cout << msg.str() << std::flush;
        //}
        return busy_;
      }

      /// @brief Service the next entry
      ///
      /// No locking is required because the queue should be serviced
      /// by a single thread (the one that set busy_ to true).
      /// @returns the entry to be processed or zero if this batch of entries is finished.
      LinkedBuffer * serviceNext()
      {
        assert(busy_);
        //std::ostringstream msg;
        //msg << "Q:{"<< (void *) this <<  "} pop @" <<(void *)peekOutgoing() << std::endl;
        //std::cout << msg.str() << std::flush;
        return outgoing_.pop();
      }

      /// @brief Service all pending entries at once
      /// @returns the first entry in a linked list of buffers.
      LinkedBuffer * serviceAll()
      {
        assert(busy_);
        //std::ostringstream msg;
        //msg << "Q:{"<< (void *) this <<  "} pop all @" <<(void *)peekOutgoing() << std::endl;
        //std::cout << msg.str() << std::flush;
        return outgoing_.popList();
      }

      /// @brief Relinquish responsibility for servicing the queue
      ///
      /// The unused scoped lock parameter indicates this method should be protected.
      ///
      /// Unless recheck is false, this call will prepare a new batch of buffers
      /// to be processed assuming any arrived while the previous batch was being
      /// serviced.  When there are more buffers, this thread must continue to
      /// process them.
      ///
      /// @param recheck should normally be true indicating that this thread is
      ///        willing to continue servicing the queue.
      /// @param lock unused parameter to be sure the mutex is locked.
      /// @returns true if there are more entries to be serviced.
      bool endService(bool recheck, boost::mutex::scoped_lock & lock)
      {
        assert(busy_);
        busy_ = false;
        if(recheck)
        {
          return startService(lock);
        }
        return false;
      }

      /// @brief Promote buffers from incoming to outgoing (service thread only)
      ///
      /// This method should be called only by the service thread
      /// Any accumulated buffers in the input queue will be appended to the output queue.
      /// If wait is false, then the return value is false if nothing was changed.
      /// if wait is true, then this call waits until some incoming buffers are available.
      /// The (external) mutex must be locked when this method is called (even if wait is false).
      /// @param lock is used for the wait.  It also confirms that the caller has locked the mutex.
      /// @param wait is true if this call should wait for incoming buffers to be available.
      /// @returns true if the incoming buffer queue has changed from empty to populated
      bool refresh(boost::mutex::scoped_lock & lock, bool wait)
      {
        assert(busy_);
        bool wasEmpty = incoming_.isEmpty();
        while(wait && wasEmpty)
        {
          //std::ostringstream msg;
          //msg << "Q:{"<< (void *) this <<  "} wait" << std::endl;
          //std::cout << msg.str() << std::flush;

          condition_.wait(lock);
          wasEmpty = incoming_.isEmpty();
        }
        if(!wasEmpty)
        {
          outgoing_.push(incoming_);
        }
        return !wasEmpty;
      }

      /// @brief A nondestructive peek at the outgoing queue.
      const LinkedBuffer * peekOutgoing()const
      {
        return outgoing_.peek();
      }

      /// @brief Apply a function to every buffer in the queue
      ///
      /// The unused scoped lock parameter indicates this method should be protected.
      ///
      /// @param f is the function to apply
      void apply(boost::function<void (LinkedBuffer *)> f, boost::mutex::scoped_lock &)
      {
        LinkedBuffer * buffer = outgoing_.peek();
        while(buffer != 0)
        {
          f(buffer);
          buffer = buffer->link();
        }
        buffer = incoming_.peek();
        while(buffer != 0)
        {
          f(buffer);
          buffer = buffer->link();
        }
      }
    private:
      BufferQueue incoming_;
      BufferQueue outgoing_;
      boost::condition_variable condition_;
      bool busy_;
      // todo: statistics would be interesting
    };
  }
}
#endif // SINGLESERVERBUFFERQUEUE_H
